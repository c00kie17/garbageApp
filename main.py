# ALL IMPORTS
from oauth2client import client as oauth2client
from oauth2client import tools
from oauth2client.file import Storage
from google.cloud import pubsub_v1
from google.cloud import pubsub 
from multiprocessing import Process
import httplib2
from apiclient import discovery
import time
import ast
from apiclient import errors
import base64
import os
import PIL
from PIL import Image
from PIL.ExifTags import TAGS, GPSTAGS
import datetime
import ssl
import pymysql
from google.cloud import storage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

#APP SETTINGS

name = "GarbageAPP" #set the name of the app you want your users to see 
myemail = "anshul1708@gmail.com" #set the email to send error emails out of, usually same as the recieveing email

#creating a mysql connection
connectionsql = pymysql.connect(host='localhost',#host is set to localhost as sql is on the same machine as the script
                             user='root',		 #user you want to connect with  
                             password='root',	 #password for the selected user
                             db='garbageapp')	 #the database you want to connect to in mysql	

cur = connectionsql.cursor(pymysql.cursors.DictCursor) # creating a cursor to read and write from the database


#setting for controlling our recieveing email

SCOPES = 'https://mail.google.com/' 			#scopes are used to set permissons that the app wants, current scope can perform all actions on an gmail id
CLIENT_SECRET_FILE = './storage/secret.json'	#secret file is generated by the api manager and is used to identify the email you want to connect to
APPLICATION_NAME = name							#name of the app you want to connect to the email id with
project_id = 'locationbasedimages'				#name of your project on google cloud platform

#creating workers for pubsub system


pubsubclient = pubsub_v1.PublisherClient()		#creating a publisher worker so create and manage topics
subscriber = pubsub_v1.SubscriberClient()		#creating a subsciber worker so create and manage subscriptions for the topics
project = pubsubclient.project_path(project_id) #setting the project you want the pubsub to work on

gmailHistoryId = '' #creating an empty varibale to hold the last history id, to make sure the process only checks the newer mails from this historyID
checkedEmails = []  #creating a empty list to add the id of all the checked mails , so as it to not check them again by mistake

#Used to get credentials for the recieveing emailid , checks if the authentication process is already performed, if not performs it.
def Getcredentials():
	store = Storage('./storage/myauth.json') 
	credentials = store.get()				
	if not credentials or credentials.invalid:									# fetches and checks if the credentials exist and if the credentials are still valid
		flow = oauth2client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)	# starts the authentication process 
		flow.user_agent = APPLICATION_NAME										# gives the auth process your application name
		credentials = tools.run_flow(flow,store)								# gets the new credentials and saves them to the myauth.json file
		print('fetched new credentials')
	return credentials  														#return the new credentials to the main program

#used to create a topic and subsciption which we can listen to for any new incoming emails
def createPubsub():
	gmail_Listener = pubsubclient.topic_path(project_id, 'gmailListener') 				#creating a topic path for gmailListener
	gmail_Listener_Sub = subscriber.subscription_path(project_id, 'gmailListenerSub')	#creating a subscription path for gmailListenerSub
	exists = any(element.name == gmail_Listener for element in pubsubclient.list_topics(project)) #checking if the topic already exists
	if not exists:
		pubsubclient.create_topic(gmail_Listener)	#creating a topic 
		policy = pubsubclient.get_iam_policy(gmail_Listener) #getting the permissions for the topic 
		policy.bindings.add(								 #creating new permission to listen to the emailid specified	
        	role='roles/pubsub.publisher',
        	members=['serviceAccount:gmail-api-push@system.gserviceaccount.com']
        )
		pubsubclient.set_iam_policy(gmail_Listener,policy)	#setting new permissions for the topic
	try:	
		exists = any(element.name == gmail_Listener_Sub for element in pubsubclient.list_topic_subscriptions(gmail_Listener)) #checking if the subsciption for the topic already exists
	except AttributeError:
		pass
	else:	
		if not exists:	
			subscription = subscriber.create_subscription(gmail_Listener_Sub, gmail_Listener)  #creating a new subsciption for the topic
	return gmail_Listener,gmail_Listener_Sub  #return the topic and the subsciption to the main program

#A helper function to parse the exif data using the exif format 
def parseExifData(info):
	exifData = {}								#creating a dictonary to store the parsed exif data
	for tag, value in info.items():				#looping though the byte values in the data
		decoded = TAGS.get(tag, tag)			#converting the byte values into string for better radability
		if decoded == "GPSInfo":				#finding the list with the GPS information
			gpsData = {}						#creating an empty dictionary to store the GPS information
			for t in value:						#looping though the byte values in the GPS information
				subDecoded = GPSTAGS.get(t, t)	#converting the byte values into string for better radability in GPS information list
				gpsData[subDecoded] = value[t]	#saving the string values into the gps data dictionary 
			exifData[decoded] = gpsData		#adding the GPS data dictionary to the exifData dictionarry	
		else:
			exifData[decoded] = value           #adding all other field converted from byte to string into the exif data dictionary
	return exifData								#returning the data with the string exif values

#A helper function to check if a field exists in a list
def getIfExist(data, key):	
    if key in data:								#checking if a key exists in a dictionary
        return data[key]						#returning the value of that key to the main fucntion
		
    return None									#if the key is not found we return None

#A helper function to convert co-ordiate valued of longitude and latitude into degress 
#this fucntion is basic mathematics of converting co-ordiantes to degress which you can read about 
def convertToDegress(value):
    d0 = value[0][0]							
    d1 = value[0][1]
    d = float(d0) / float(d1)

    m0 = value[1][0]
    m1 = value[1][1]
    m = float(m0) / float(m1)

    s0 = value[2][0]
    s1 = value[2][1]
    s = float(s0) / float(s1)

    return d + (m / 60.0) + (s / 3600.0) 

#A helper fucntion to create email body and convert it into a byte object 
def createMessageHtml(sender, to, subject, message_text):
		message = MIMEMultipart()
		message['to'] = to
		message['from'] = sender
		message['subject'] = subject
		msg = MIMEText(message_text)
		message.attach(msg)
		b64_bytes = base64.urlsafe_b64encode(message.as_bytes())
		b64_string = b64_bytes.decode()
		return {'raw': b64_string}



def userError(userEmail,reason):
	if not userEmail == '':
		subject =  name+" Oops something went wrong with you submission"
		message = "Hi\n The picture you sent"
		if reason == "exists":
			message = message + " is already in our database!"
		elif reason == "corrupt":	
			message = message + " seems to have something wrong with it. It would be awesome if you could snap another one."
		elif reason == "old":	
			message = message + " is too old for us to accept it. This maybe a problem with your phones time, if so please set it to the current time and try again. "
		elif reason == "nodata":	
			message = message + " seems to be missing some data. This maybe because your location service for pictures is turned off, if so please turn it on and try again. "
		else :	
			message = message + " does not seem to exists in the email. If you forget to attach it, it would be awesome if you could send another email with the picture attached."
		message = message + "\n Thank you"
		formattedEmail  = createMessageHtml(myemail,userEmail,subject,message)	
		try:
			message = gmail.users().messages().send(userId='me', body=formattedEmail).execute()
		except errors.HttpError as error:
			print ('An error occurred '+ str(error))

def uploadToStorage(filepath,filename):
	client = storage.Client()
	try:
		bucket = client.get_bucket('garbagephotos')
	except NotFound:
		print("instrument bucket does not exist")
	else:
		blob = bucket.blob(filename)
		blob.upload_from_filename(filepath)
		os.remove(filepath)    

def loadIntoTable(dataList,userEmail):
	query = "SELECT * FROM photodata WHERE filename_unique = %s"
	cur.execute(query,dataList['filenameUnique'])
	result = cur.fetchone()
	if result == None:
		query = "INSERT INTO photodata (`email`,`longitude`,`latitude`,`filename`,`picture_timestamp`,`email_timestamp`,`filename_unique`)  VALUES (%s,%s,%s,%s,%s,%s,%s)" 
		cur.execute(query,(dataList['userEmail'],dataList['longitude'],dataList['latitude'],dataList['filename'],dataList['photoTimestamp'],dataList['emailTimestamp'],dataList['filenameUnique']))
		connectionsql.commit()
		return True
	else:
		userError(userEmail,'exists')	
		return False

def getlocationdata(filepath,senderEmail):
	img = Image.open(filepath)
	info = img._getexif()
	if info:	
		exifData = parseExifData(info)
		if 'DateTimeOriginal' in exifData and 'GPSInfo' in exifData:
			photoTimestamp = exifData["DateTimeOriginal"]
			photoTimestamp = datetime.datetime.strptime(photoTimestamp,"%Y:%m:%d %H:%M:%S")
			now = datetime.datetime.now()
			yesterday = now - datetime.timedelta(days = 1)
			if yesterday < photoTimestamp:		
				lat = None
				lon = None		
				gpsInfo = exifData["GPSInfo"]
				gpsLatitude = getIfExist(gpsInfo, "GPSLatitude")
				gpsLatitudeRef = getIfExist(gpsInfo, 'GPSLatitudeRef')
				gpsLongitude = getIfExist(gpsInfo, 'GPSLongitude')
				gpsLongitudeRef = getIfExist(gpsInfo, 'GPSLongitudeRef')
				if gpsLatitude and gpsLatitudeRef and gpsLongitude and gpsLongitudeRef:
					lat = convertToDegress(gpsLatitude)
					if gpsLatitudeRef != "N":                     
						lat = 0 - lat
					lon = convertToDegress(gpsLongitude)
					if gpsLongitudeRef != "E":
						lon = 0 - lon  
					dataList = {'longitude':lon,'latitude':lat,'photoTimestamp':photoTimestamp}  
					return dataList
				else:
					userError(senderEmail,'corrupt')        
			else:
				userError(senderEmail,'old')
		else:
			userError(senderEmail,'nodata')					     	    
	else:
		userError(senderEmail,'nodata')	

def fetch_attachment():
	try:
		history = gmail.users().history().list(userId='me',startHistoryId=gmailHistoryId).execute()
	except ssl.SSLError:	
		pass
	else:		
		changes = history['history'] if 'history' in history else []
		if len(changes) > 0:
			messageId = changes[-1]['messages'][0]['id']
			if messageId not in checkedEmails:
				try:
					message = gmail.users().messages().get(userId='me', id=messageId).execute()
				except errors.HttpError:	
					fetch_attachment()
				except ssl.SSLError:	
					pass	
				else:
					checkedEmails.append(messageId)
					flag = True
					senderEmail = ''
					for header in message['payload']['headers']:
						if header['name'] =='Return-Path':
							senderEmail = header['value']
							senderEmail =  str(senderEmail).strip('<>')
					if 'parts' in message['payload']:
						for part in message['payload']['parts']:
							if part['filename']:
								flag = False
								attachmentId = part['body']['attachmentId']
								try:
									attachmentData = gmail.users().messages().attachments().get(id=attachmentId,messageId = messageId,userId='me').execute()
								except errors.HttpError:	
									fetch_attachment()
								else:	
									file_data = base64.urlsafe_b64decode(attachmentData['data'].encode('UTF-8'))
									curpath = os.path.abspath(os.curdir)
									path = ''.join(['./photos/', part['filename']])
									file = open(path, 'wb+')
									file.write(file_data)
									file.close()
									dataList = getlocationdata(path,senderEmail)
									if dataList is not None:
										dataList['userEmail'] = senderEmail
										dataList['emailTimestamp'] = datetime.datetime.now()
										dataList['filename'] =  part['filename']
										dataList['filenameUnique'] = str(part['filename'])+str(senderEmail)+str(dataList['photoTimestamp'])
										if loadIntoTable(dataList,senderEmail):
											uploadToStorage(path,part['filename'])
										else:
											os.remove(path)	
						if flag:
							userError(senderEmail,'noattachment')		
												

#callback function which fires everytime a new email is sent to the watched emailid
def new_email_listener(message):									
	#remove
	print('checked email')
	email = ast.literal_eval(message.data.decode('utf-8'))		#converting the byte data recieved in a python list for easier readibility
	fetch_attachment()											#calling a fucntion to fetch the attachment from the new email
	gmailHistoryId = email['historyId']							#setting the history id to the new historyId recieved with the email
	message.ack()												#acknowledgement sent back to the pubsub telling it we have receieved the message and not to send it again


if __name__ == '__main__':
	credentials = Getcredentials()                                      #calling function to check if the authentication credentials exist if not performs the authentication again and return the new credentials 
	http = credentials.authorize(httplib2.Http())						#with the credentials, authorizes the api to be able to use the email.
	gmail = discovery.build('gmail', 'v1', http=http)					#creating a gmail api object
	topic_path,subscription_path = createPubsub()						#calling a function to check if the pubsub topic and subsciption exist if not creating them , setting thier permission and returning thier values
	subscriber.subscribe(subscription_path, callback=new_email_listener)#subscibing to listen to the subsciption for any new emails and setting a callback to fire on an event
	request = {															# setting the topic setting to listen to new emails such as the labeltype we want to listen to and what topic it should send its push notification to
	  'labelIds': ['INBOX'],
	  'topicName': topic_path
	}
	res = gmail.users().watch(userId='me', body=request).execute()		#calling to gmail object to set the push notification system to listen to emails
	gmailHistoryId = res['historyId']									#once the watch object is set it gives us the current historyID which is save 
	print('Listening for emails')
	while True:															#looping the thread to keep checking if there are any new emails recieved otherwise the program will exit here
		time.sleep(10)

	





	